---
layout: post
title: "네트워크 - Distance Vector Routing(2)"
tags: [컴퓨터 네트워크]
comments: true

---

컴퓨터 네트워크를 공부하면서 정리를 한 내용들 입니다.

-참고 K-mooc 부산 대학교 유영환 교수님 : 컴퓨터 네트워크 강의

---

# Note : "Good News Travels Fast"

<img src="">

distance vector algorithm에서 good news는 빨리 전달 된다는 장점이 있습니다.

어떻게 good news는 빨리 전달 되는가 살펴 보겠습니다.

그림을 보시면 x, y와 z가 각각 연결 되어 있고, 

z는 distance vector를 주고 받으면서 

처음에 y에서 x로의 값이 1로 바뀌기 전, 

4, 1과 3일 때에는 z에서 x측으로 가기 위해 y를 거쳐가면 5의 비용이 들기 때문에

x로 갈 때 3의 비용으로 바로 직접 연결을 했습니다.

그런데 값이 4에서 1로 줄었다면?

<img src="">

그러면 z는 3의 비용으로 직접 x로 전달 하는 것 보다는

y로 거쳐 갈 때 1+1=2의 비용으로 갈 수 있다는 것을 알게 됩니다.

그래서 바로 y를 거쳐서 전달 하게끔 바뀌게 됩니다.

이렇게 해서 비용이 4에서 1로 줄었다는 것은 금방 알려지게 된다는 것 입니다.

# Note : "Bad News Travels Slow"

<img src="">

distance vector algorithm에서 문제가 될 수 있는 것은 bad news 입니다. 

현재 그림에선 x, y, z가 연결 되어 있고 비용이 1과 4와 50으로 되어 있었습니다.

그래서 z는 원래 y로 보낼 때는 y로 보내고 있었고 

x로 보낼 때도 y로 거치는 것이 더 비용이 적어 그쪽으로 보내고 있었습니다. 

여기서 x에서 y로 가는 비용이 4에서 60으로 증가 했습니다.

y가 60으로 되었다는 것을 감지 했습니다.

y의 입장에서 z가 보내온 케이블을 보니

z가 5의 비용으로 갈 수 있다고 말해옵니다.

사실 z는 5의 비용으로 갈 수 있다는 것은 값이 바뀌기 전의 거치는 비용 5입니다.

y는 그 사실을 모르기 때문에 z를 통해 전송을 하게 됩니다.

Dz(x) 이 값이 5이므로, C(y,z)+ Dz(x)는 6이 됩니다.

그리고 테이블을 이렇게 (y,x) 비용을 6이라고 바꿔서 z한테 전달 합니다.

그럼 z는 아까는 y가 4의 비용으로 갈 수 있다고 했는데, 

이번에는 6의 비용으로 갈 수 있다고 하니 여전히 50보다 작기 때문에 

값을 7로 갱신 해서 다시 y와 주고 받게 됩니다.

결론적으로, 사실 z는 y를 통해서 보내고 y는 z를 통해서 보내는 것인데 

비용 값이 계속 서로 1씩 증가 한 값을 계속 주고 받게 됩니다.

처음 y가 z로 보낸 첫 테이블의 값, 처음 6에서 7, 8, 9, 10 왔다 갔다 하면서

하나씩 증가 하다가 값이 50이 되면 z에서 x측으로 보내는 방식이 더 효율적일 때.

그 때 가서야 z는 y를 거쳐 보내지 말고 보내야한다는 사실을 알게 됩니다.

이렇게 계속 증가하는 문제를 count to infinity problem라고 이야기 합니다.

그리고 보통 distance vector를 주고 받는 주기가 설정 마다 다르지만 

30초 정도로 보통 많이 설정 됩니다.

그럼 6에서 50까지 44회를 주고 받으려면 약 20분 정도 시간이 걸리게 됩니다. 

그래서 이런 문제를 완화하기 위해서 poisened reverse라는 제한이 생겼습니다.

예를 들어서 Z가 X로 가는 길이 Y를 통해서 간다고 하면 

Z는 Y에게 자신이 X로 가는 비용은 무한대이라고 알려줍니다.

여기서의 문제는 Z는 Y를 거쳐가면서 Y한테 말하기를

자기는 5의 비용으로 갈 수 있다 이야기 했던게 문제거든요.

그럼 Y는 Z가 5의 비용으로 가는 길이 있다고 하니까

거기에다 1을 더하면 6으로 갈 수 있겠구나 이렇게 생각 한 것이거든요. 

차라리 Z가 Y한테 자기는 Y를 거쳐서 보내면서 Y한테 말 할 때는

X로의 길이 없다 또는 무한대다 이렇게 말했다면 Y는 이 길을 선택하려 하지 않았겠죠.

그렇다고 해서 이것이 완벽한 해결책은 되지 않습니다. 

직접 이렇게 연결 된 두 node 사이에 일어 났을 때는 해결책이 될 수도 있겠지만

만약에 이 사이에서 loop이 일어났다. 여러 개의 node가 서로 원형으로 loop을 만들었다 할 때는

이런 식으로 해결이 안 되기 때문에 완벽한 해결책이 되지는 못합니다.

---
