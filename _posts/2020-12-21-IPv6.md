---
layout: post
title: "네트워크 - IPv6"
tags: [컴퓨터 네트워크]
comments: true

---

컴퓨터 네트워크를 공부하면서 정리를 한 내용들 입니다.

-참고 K-mooc 부산 대학교 유영환 교수님 : 컴퓨터 네트워크 강의

---

# IPv6 Motivation

`DHCP`나 `network address translation`에서 부족한 IP주소 문제를 

<strong>"어느 정도"</strong> 해결 할 수 있는 방안을 제시 해 주었습니다. 

이런 해결책은 기존에 있는 인터넷 5 계층의 원칙을 파괴하는 문제점도 

있기 때문에 `DHCP`나 `NAT`를 가지고 주소 부족 문제를 

완전하게 해결 할 수는 없다 라고 판단을 했습니다. 

그래서 90년대부터 일단 주소의 고갈이 다가 올 것이라고 예상을 했고,

2011년에 마지막 남아 있는 IP 주소 pool를 

어떤 나라의 주소를 관리하는 기관에 할당을 했습니다.

"근본적인 해결책은 주소 개수 자체를 늘리는 수 밖에 없다." 로 판단했고,

주소의 개수를 늘리는 작업에 착수를 했습니다. 

거기다가 그것만 해결하면 되는 것이 아니라 2,30년 전 네트워크 상황과 

현재 상황이 많이 다르기 때문에 기존에 헤더 포맷을 수정하기 시작했습니다.

그렇게 하면서 과거에 없던 멀티미디어 트래픽들이 많이 등장 했기 때문에 

서로 다른 타입의 트래픽들이 요구하는 QoS(Quality of Service)를 보장해 줄 수 있는,

그러한 정보들을 담을 수 있는 헤더를 만들게 되었습니다.

## IPv6 feature

IPv6 헤더의 특징은, 일단 Fixed Length, 고정된 크기의 40 byte 헤더입니다. 

IPv4의 헤더는 20byte로 2배 늘어나게 되었습니다.

그러나 결론적으론 더 복잡해 진 것이 아닙니다.

source address와 destination address가 128bit(16byte)씩으로 늘어났습니다.

이 두 개만 32 byte이고, 나머지 헤더는 8 byte 밖에 되지 않는다는 점 입니다.

IPv4 같은 경우에는 source address와 destination address가 각각 4 byte씩, 

나머지 헤더 길이가 12 byte 였습니다. 

그래서 주소의 길이를 뺀 나머지 필드만 비교 해 보면 

오히려 IPv6가 오히려 더 줄어듦으로써 훨씬 더 간략해졌다고 볼 수 있습니다.

어떤 부분이 간략해 졌나 살펴보면 일단 12 byte와 8 byte의 차이는 4 byte로

Fragmentation ID, fragmentation offset, flag가 있었는데 

이 4 byte가 없어졌습니다.

### why?

IPv6에서는 중간 라우터가 데이터그램을 쪼개고 그것이 목적지에 도달 했을 때 

다시 합치는 fragmentation reassembly 과정을 없앴습니다.

이렇게 fragmentation과 reassembly 과정을 없앤 것엔

70년대의 네트워크에 비해 전 세계 네트워크는 훨씬 더 균일화 되었기 때문입니다.

그래서 Maxium transfer unit size가 많이 다르지 않아졌으므로,

굳이 fragmentation이 중간에 일어나야 되는 필요성이 줄었습니다.

# IPv6 Datagram Format

몇 가지 남아 있는 필드들을 살펴봅시다.

<img src="">

version은 버전 4나 6을 갖는 부분입니다. 

priority는 보내는 데이터그램 중에 특별히 중요한 데이터그램이 있다면,

priority를 부여 합니다.

priority를 부여 한다고 해서  중간에 라우터에서 어떻게 해 준다는 보장은 없지만,

중간에 어떤 라우터가 이 priority scheduling을 한다면

그러면 priority가 높은 데이터는 buffer overflow 상황이 발생 해도 

priority가 높은 것은 버리지 않고 keep을 해 두는 등의 우선순위를 둘 수 있습니다.

Flow lable은 IPv4에서는 없던 개념입니다.

IPv4에서의 데이터그램은 같은 프로세스에서 출발해서 같은 프로세스로 도착하는 

연속적인 데이터그램 이라고 하더라도 각자 독립적으로 취급되었습니다. 

그런데 IPv6에서는 source 프로세스가 있고, 

다른 원격 컴퓨터에 receiver 프로세스가 있다고 하면

이 사이에 흘러가는 이 IP 데이터그램들에 같은 flow lable을 부여 해서

하나의 flow로 취급 할 수 있게 생각하게 했습니다.

flow lable이 생기면서 checksum이 없어졌습니다. 

Checksum을 없앤 이유는 실제 네트워크 전송 속도를 빠르게 하기 위함입니다.

checksum을 할 때 CRC, Cyclical Redundancy Check를 하면서,

시간이 오래 걸리게 되기 때문입니다.

payload length는 데이터 payload 부분의 길이를 뜻 합니다.

next header는 상위 레이어에 어떤 프로토콜을 사용하는지 확인하는 곳 입니다.

IPv4에도 옵션 헤더라는 것이 있었는데 IPv6에도 옵션이라는 것을 둘 수 있습니다.

잘 두지는 않지만 옵션을 두게 되면 그 부분을 next header가 가리킵니다.

hop limit이라는 것은 IPv4에 있었던 time-to-live, TTL하고 같은 개념입니다.

---
